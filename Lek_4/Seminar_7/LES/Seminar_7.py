# Задача №1. Решение в группах У вас есть код, который вы не можете менять
# (так часто бывает, когда код в глубине программы используется множество раз 
#  и вы не хотите ничего сломать): 
# transformation = <???> 
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список 
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом 
# посредством задания функции transformation. Однако вы поняли,
# что для вашей текущей задачи вам не нужно никак преобразовывать список значений,
# а нужно получить его как есть. Напишите такое лямбда-выражение transformation,
# чтобы transformed_values получился копией values. Пример ввода и вывода данных
# представлены на следующем слайде 20 минутСеминар 7. Функции высшего порядка Задача №1. 
# Решение в группах Ввод: 
# trasformation = lambda y: y
# values = [1, 23, 42, 'asdfg'] 
# transformed_values = list(map(trasformation, values)) 
# if values == transformed_values:    
#   print('ok') 
# else:   
#   print('fail') 

######################################################################################################################################
  
# Задача №2. Решение в группах Планеты вращаются вокруг звезд по эллиптическим орбитам. 
# Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь.
# Напишите функцию f ind_farthest_orbit(list_of_orbits), 
# которая среди списка орбит планет найдет ту, по которой вращается самая далекая планета.
# Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет нет, 
# зато искусственные спутники были были запущены на круговые орбиты. 
# Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой 
# далекой планеты. Каждая орбита представляет из себя кортеж из пары чисел - полуосей ее эллипса. 
# Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины полуосей эллипса. 
# При решении задачи используйте списочные выражения. 
# Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса,
# а затем найти и сам эллипс, имеющий такую  площадь. Гарантируется, что самая далекая планета ровно одна
# Пример ввода и вывода данных представлены на следующем слайде 20 минутСеминар 7.
# Функции высшего порядка Задача №2. Решение в группах Ввод:
#   orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] 
#   print(*find_farthest_orbit(orbits)) 
#   Вывод: 2.5 10
# from math import pi
# def find_farthest_orbit(orbits):
#   Orbity = [x for x in orbits if x[0]!=x[1]]
#   S_orbits = [pi*x[0]*x[1] for x in Orbity]
#   max_S_Orb_inx= S_orbits.index(max(S_orbits))
#   return Orbity[max_S_Orb_inx]
     
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] 
# print(*find_farthest_orbit(orbits))
# ####
################################################################################################################

# Задача №3. Общее обсуждение 
# Напишите функцию same_by(characteristic, objects), которая проверяет, 
# все ли объекты имеют одинаковое значение некоторой характеристики, и возвращают True, если это так.
# Если значение характеристики для разных объектов отличается - то False. 
# Для пустого набора объектов, функция должна возвращать True. 
# Аргумент characteristic - это функция, которая принимает объект и вычисляет его характеристику.
# Ввод: 
#   values = [0, 2, 10, 6] 
#   if same_by(lambda x: x % 2, values): 
#     print('same') 
#   else:
#     print('different')
# Вывод: same

# # Мой вариант решения задачи!
# def same_by(f,val):
#   return all([f(x)==0 for x in val])
# values = [ 1,0, 2, 10, 6] 
# if same_by(lambda x: x % 2, values): 
#   print('same') 
# else:
#   print('different')

# Вариант решения задачи от препода:
def same_by(characteristic,objects):
  result = True
  list1=[characteristic(x) for x in objects]
  for i in range(len(list1)-1):
    if list1[i]!=list1[i+1]:
      result =  False
  return result

values = [0, 2, 10, 6] 
if same_by(lambda x: x % 2, values): 
  print('same') 
else:
  print('different')