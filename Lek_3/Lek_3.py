# # Функция — это фрагмент программы, используемый многократно
# # Функция вычисления суммы N элементов
# def SumNum(n):
#   SumN = 0
#   for i in range(1,n+1):
#     SumN+=i
#   return(SumN)
# # Sum=SumNum(int(input("Input N: ")))
# print(SumNum(int(input("Input N: "))))

#######################################################

# # Если мы хотим передать неограниченное кол-во аргументов то нужно перед принимающей переменной ставить звездочку "*"
# def Sum_str(*argum):
#   res=''
#   for i in argum:
#     res+=i
#   return res
# print(Sum_str('a','f','r','u'))
# print(Sum_str('a','f','r','u','a','f','r'))

###############################################################

# #Вы  когда-нибудь  задавались  вопрос,  как  например  работает  функция  .append
# # Это же точно такая же функция, как и sumNumbers(n), но мы ее нигде не создаем, 
# # все  дело  в  том  что,  это  функция  автоматически  срабатывает  и  чтобы  ей 
# # пользоваться  ничего  дополнительно  писать  не  надо.
# # Представьте  себе  такую  ситуацию,  что  Вы  создаете  огромный  проект  и  у  Вас 
# # имеется  большое  количество  функций,  к  примеру  5  функций  работают  со 
# # словарями,  18  со  списками  и  тд.  и  у  каждой  функции  свой  алгоритм,  но  их 
# # объединяет работа с одной коллекцией данных. Согласитесь неудобно работать в 
# # таком  большом  файле,  где  около  80  функций,  очень  легко  потеряться  и  на 
# # перемотку кода Вы будете терять драгоценное время. Решение данной проблемы 
# # есть.  Давайте  будем  создавать  отдельные  файлы,  где  будут  находиться  только 
# # функции, и эти функции при необходимости вызывать из главного файла
# # Применение МОДУЛЬНОСТИ (Модульность это когда под каждую отдельную

# функцию создается отдельный файл и потом в основном файле вызывается
# в виде import modul - <Имя файла модуля с функцией> и ссылка modul.max(5,9))
# import modul
# print(modul.max(5,20))

# # Но не обязательно импортировать наш модуль писать import файлик, а напрямую импортировать 
# # из нашего модуля функцию, т.е
# from modul import max
# print(max(5,20))

# Еще мы не знаем название всех функций в нужном нам модуле или нам лень перечислять названия 
# всех функций привызове, то можно поставить * вместо названия функции, т.е:
# from modul import *
# print(max(555,20))

# Еще исли имя импортируемого модуля длинное можно уже в программе где будет вызываться модуль
# изменить его имя (с помощью "as" )и дальше в рамкахнашей программы использовать при вызове его короткое имя:
# import modul as m1
# print(m1.max(5,20))

#####################################################################################

# # Рекурсия — это функция, вызывающая сама себя.
# # С рекурсией Вы знакомы с C#, в Python она ничем не отличается, давай рассмотрим 
# # следующую задачу: Пользователь вводит число n. Необходимо вывести n - первых 
# # членов последовательности Фибоначчи.
# # Напоминание: Последовательно Фибоначчи, это такая последовательность, в 
# # которой каждое последующее число равно сумму 2-ух предыдущих.
# # При  описании  рекурсии  важно  указать,  когда  функции  надо  остановиться  и 
# # перестать  вызывать  саму  себя.  По-другому  говоря,  необходимо  указать  базис 
# # рекурсии

# # Вычисляем число фибоначи:
# # Внутри функции fib(n), мы сначала задаем базис, если 
# # число n равно 1 или 2, это означает, что первое число и 
# # второе число последовательности равны 1. Мы так и 
# # делаем возвращаем 1. Как мы ранее проговорили: 
# # “Последовательно Фибоначчи, это такая 
# # последовательность, в которой каждое последующее число 
# # равно сумму 2-ух предыдущих”. Так и делаем, складываем 
# # на 2 предыдущих числа друг с другом и получаем 3.
# def fib(n):
#   if n in [1,2]:
#     return 1
#   return fib(n-1)+fib(n-2)

# list_1 =[]
# for i in range(1,10):
#   list_1.append(fib(i))
# print(list_1)

######################################################################################

# # Алгоритмы

# # Алгоритмом называется набор инструкций для выполнения 
# # некоторой  задачи.  В  принципе,  любой  фрагмент 
# # программного  кода  можно  назвать  алгоритмом,  но  мы  с 
# # Вами  рассмотрим  2  самых  интересных  алгоритмы 
# # сортировок:
# # ● Быстрая сортировка
# # ● Сортировка слиянием

# Быстрая сортировка
# “Программирование это разбиение чего-то большого и невозможного на что-то маленькое и 
# вполне реальное”
# Быстрая  сортировка  принадлежит  такой  стратегии,  как  “разделяй  и  властвуй”.  Сначала 
# рассмотрим пример, затем напишем программный код
# def quick_sort(array):
#   if len (array)<=1:
#     return array
#   else:
#     pivot = array[0]
#   less = [i for i in array[1:] if i<= pivot]
#   # print(less)
#   greater = [i for i in array[1:] if i>pivot]
#   # print(greater)
#   s=quick_sort(less) + [pivot] + quick_sort(greater)
#   #print(s)
#   return s
# print(quick_sort([10,5,2,3]))
 
# Быстрая сортировка разбор алгоритма функции quick_sort(array)
# ● 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии 
# добавляется список [10]
# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5, 10]

#################################################################################################################################

## СОРТИРОВКА СЛИЯНИЕМ!!
def merge_sort(nums):
  if len(nums)>1:
    mid=len(nums)//2
    left=nums[:mid]
    right=nums[mid:]
    merge_sort(left)
    merge_sort(right)
    # print(left, "left",      right, "right")
    i=j=k=0
    while i<len(left) and j<len(right):
      if left[i]<right[j]:
        nums[k]=left[i]
        i+=1
        # print(nums, 'i', i, k)
      else:
        nums[k]=right[j]
        j+=1
        # print(nums, 'j', j, k)
      k+=1
    while i<len(left):
      nums[k]=left[i]
      # print(nums, 'i ost', i, k)
      i+=1
      k+=1
    while j < len(right):
      nums[k]=right[j]
      # print(nums, 'j ost', j, k)
      j+=1
      k+=1
  return (nums)
list1 = [3,4,2,5,76,8,6,7,9,8,21,14,55,66,77]
print(merge_sort(list1))
    