# # #Список  -  это  упорядоченный  конечный  набор  элементов.  Давайте 
# # разбираться, по сути список - это тот же самый массив, в котором 
# # можно хранить элементы любых типов данных. Как работать со списками?
# list_1 = [] # Создание пустого списка
# list_2 = list() # Создание пустого списка
# list_1 = [7, 9, 11, 13, 15, 17]
# print (list_1)   # программ введет [7, 9, 11, 13, 15, 17]
# print (*list_1) # Что бы не отображались [] и запятые в скобках ставим * перед переменной, программа введет 7 9 11 13 15 17

# # В  списках  существует  нумерация,  которая  начинается  с  0,  чтобы 
# # вывести  первый  элемент  списка  воспользуемся  следующей конструкцией:
# list_1 = [7, 9, 11, 13, 15, 17]
# print(list_1[0]) # выведет 7
# print(len(list_1[0]))  # выведет 6, функция len выводит количество значений в нашем списке

# # Добавление значения в конец нашего списока для этого есть надстройка функция - .append(значение)
# 1.
# list_1 = [7, 9, 11, 13, 15, 17]
# print(list_1) # программ введет [7, 9, 11, 13, 15, 17]
# list_1.append(56)
# print(list_1) # программ введет [7, 9, 11, 13, 15, 17, 56]
# 2.
# list_1 = []
# print(list_1)
# for i in range (5):
#   list_1.append(i)
#   print(list_1)
# 3.
# # программа ввода с консоли пользователем списка (массива) чисел поочередно по циклу: 
# list_1 = list() # создание пустого списка
# for i in range(5): # цикл выполнится 5 раз
#   n = int(input()) # пользователь вводит целое число
#   list_1.append(n) # сохранение элемента в конец списка
# print(list_1)


# # Удаление последнего элемента списка.
# # Метод pop() -  удаляет (вырезает) последний элемент из списка:
# list_1 = [12, 7, -1, 21, 0]
# print(list_1.pop()) # 0 
# print(list_1) # [12, 7, -1, 21]
# print(list_1.pop()) # 21
# print(list_1) # [12, 7, -1]
# print(list_1.pop()) # -1
# print(list_1) # [12, 7]

# # И еще Метод pop() -  удаляет (вырежет) последний элемент из списка и если использовать 
# его в присвоении новой переменной то рор вырезеное значение может вернуть ей:
# list_1 = [12, 7, -1, 21, 0]
# a = list_1.pop(-2) # pop(-2) вырезало из списка второе с конца значение и присвоело его переменной а
# print(a) # 21 
# print (list_1) # [12, 7, -1, 0] в нашем списке уже нет значения 21 

# # # Или, еслси в скобках указано значение pop(1) - то метод удаляет второй посчету элемент из списка
# # (второй потому, что нумерация начинается с 0):
# list_1 = [12, 7, -1, 21, 0]
# print(list_1.pop(1)) # 7 вырезается и выводится оператором принт 
# print(list_1) # оператор принт выведет нам [12, -1, 21, 0]


# # # Добавление элемента на нужную позицию.
# # # Функция insert (идекс, значение) — указание индекса (позиции) и значения.
# list_1 = [12, 7, -1, 21, 0]
# print(list_1.insert(2, 11))
# print(list_1) # [12, 7, 11, -1, 21, 0]

# # Срез списка
# # Помните в конце первой лекции Вы прошли срезы строк? Также существует срез списка, 
# # давайте научимся изменять наш список
# # ● Отрицательное число в индексе — счёт с конца списка
# list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# print(list_1[0])                           # 1
# print(list_1[1])                           # 2
# print(list_1[len(list_1)-1])               # 10
# print(list_1[-5])                          # 6
# print(list_1[:])                           # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# print(list_1[:2])                          # [1, 2]
# print(list_1[len(list_1)-2:])              # [9, 10]
# print(list_1[2:9])                         # [3, 4, 5, 6, 7, 8, 9]
# print(list_1[6:-18])                       # []
# print(list_1[0:len(list_1):6])             # [1, 7]
# print(list_1[::6])                         # [1, 7]


# # Кортеж — это неизменяемый список.
# # Тогда для чего нужны кортежи, если их нельзя изменить? В случае защиты каких-либо 
# # данных от изменений (намеренных или случайных это пароли и неизмен конфигурации). Кортеж занимает меньше места в 
# # памяти и работают быстрее, по сравнению со списками
# t = () # создание пустого кортежа
# print(type(t))    # class <'tuple'>
# t = (1,)          # здес интерпретатор посчитал что это картеж так как указано одно значение и запятая
# print(type(t))    # class <'tuple'>
# t = (1)           # здес интерпретатор посчитал что это целое число так как указано одно значение и нет запятых
# print(type(t))    # <class 'int'>
# t = (28, 9, 1990)
# print(type(t))    # class <'tuple'>

# # # Преобразование списков в кортежи
# v = [1,4,6,8,10]   # присваеваем v список значений
# print(v)           # [1, 4, 6, 8, 10]
# v=tuple(v)         # переводис с класса списка в класс кортеж
# print(v)           # получили (1, 4, 6, 8, 10) - по круглым скобкам видим что это кортеж
# a,b,c,d,e = v      # распаковываем кортеж и привсаеваем попорядку от 1го до 5го значения переменным a,b,c,d,e
## Множественное присваевание в пайтоне: a,b,c = 1,2,5 (равносильно a=1, b=2, c=5) или a=b=c=1 (равносильно a=1, b=1, c=1)
# print(a,b,c,d,e)   # получили 1 4 6 8 10

# # # Можно распаковать кортеж в независимые переменные:
# t = tuple(['red', 'green', 'blue'])
# red, green, blue = t
# print('r:{} g:{} b:{}'.format(red, green, blue)) # r:red g:green b:blue

# ## Сходство работы со списками и кортежами:
# list_1 = (1,4,6,8,10,)
# print(list_1)
# for i in range (len(list_1)):
#   print(list_1[i])
#   # или можно тоже самое
# for i in list_1:
#   print(i)
# ## различие работы со списками и кортежами в том что мы не можем в кортежах изменить уже ранее введенные значения, а в остальном они похожи:
# list_1 = (1,4,6,8,10,)
# print(list_1)
# list_1[1] = 2 #
# print(list_1) # интерпретатор при запуске выведет ошибку - TypeError: 'tuple' object does not support item assignment

# # Словари
# # Словари — неупорядоченные коллекции произвольных объектов с доступом по ключу.
# # В  списках  в  качестве  ключа  используется  индекс  элемента.  В  словаре  для  определения 
# # элемента используется значение ключа (строка, число).
# dictionary = {}      # Обозначение пустого словаря
# dictionary = dict()  # ИЛИ так Обозначение пустого словаря
# dictionary = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
# print(dictionary)  # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}
# print(dictionary['left'])  # ← типы ключей могут отличаться
# print(dictionary['up'])   # ↑ типы ключей могут отличаться
# dictionary['left'] = '⇐' # переприсваивания 'left': '⇐' в наш словарь т.е. ключа 'left' и значения его '⇐'
# print(dictionary['left']) # ⇐ 
# # print(dictionary['type']) # KeyError: 'type'  такого ключа нет в нашем словаре
# del dictionary['left'] # удаление элемента
# # В словаре могут использоваться разные типы данных: ('' - строковые, числовые 56: 435, словари и тд)
# dictionary[56] = 435
# print(dictionary)    # {'up': '↑', 'down': '↓', 'right': '→', 56: 435}

# dictionary = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
# for item in dictionary: 
#   # print('{}: {}'.format(item, dictionary[item])) # выводит ключи и через : значения попорядку из словоря
#   # print(dictionary[item]) # выводит только значения без ключей попорядку из словоря
#   print(item) # выводит только ключи без значений попорядку из словоря
# for (k,v) in dictionary.items(): # можно и так записать 
#    print(k,v) # выводит ключи и через : значения попорядку из словоря

# # Множества
# # Множества содержат в себе уникальные элементы, не обязательно упорядоченные.
# # Одно множество может содержать значения любых типов. Если у Вас есть два множества, 
# # Вы  можете  совершать  над  ними  любые  стандартные  операции,  например,  объединение, 
# # пересечение и разность. Давайте разберем их.
colors = {'red', 'green', 'blue'}
print(colors) # {'red', 'green', 'blue'}
colors.add('red')  # Добавление в наше множество значения 'red', так как множество 
# содержит только уникальные значения, а у нас 'red' уже есть в множестве то повторно 'red' не будет добавлен
print(colors)  # {'red', 'green', 'blue'}
colors.add('gray') # Добавление в наше множество значения 'gray', так как множество 
# содержит только уникальные значения, а у нас 'gray'нет в множестве то 'gray' будет добавлен в произвольное место
print(colors)  # {'red', 'green', 'blue','gray'}
colors.remove('red') # Удаление значения  'red' из нашего множества
print(colors)  # {'green', 'blue','gray'}
colors.remove('red') # KeyError: 'red' Если в нашем множестве нет значения 'red', и мы пытаемся его удалиить то интерпретатор вывндет ошибку
colors.discard('red')  # ok функция .discard('red') проверяет есть ли в нашем множестве зн 'red', если есть то
                       #удаляет или если нет то не будет выводить ошибку и просьо перейдет на след строку
a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21}
c = a.copy()            # c = {1, 2, 3, 5, 8}
u = a.union(b)          # u = {1, 2, 3, 5, 8, 13, 
i = a.intersection(b)   # i = {8, 2, 5}
dl = a.difference(b)    # dl = {1, 3}
dr = b.difference(a)    # dr = {13, 21}
q = a.union(b).difference(a.intersection(b)) # {1, 21, 3, 13}

# Неизменяемое или замороженное множество(frozenset) — множество, с которым не будут 
# работать методы удаления и добавления.
a = {1, 2, 3, 5, 8}
b = frozenset(a)
print(b) # frozenset({1, 2, 3, 5, 8}) Brad 

